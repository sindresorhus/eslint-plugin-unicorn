# Snapshot report for `test/prefer-prototype-methods.mjs`

The actual snapshot is saved in `prefer-prototype-methods.mjs.snap`.

Generated by [AVA](https://avajs.dev).

## Invalid #1 1 | const foo = [].push.apply(bar, elements);

> Output

    `␊
      1 | const foo = Array.prototype.push.apply(bar, elements);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].push.apply(bar, elements);␊
        |             ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #2 1 | const foo = [].slice.call(bar);

> Output

    `␊
      1 | const foo = Array.prototype.slice.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].slice.call(bar);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #3 1 | const foo = {}.toString.call(bar);

> Output

    `␊
      1 | const foo = Object.prototype.toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.toString.call(bar);␊
        |             ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #4 1 | const foo = {}.hasOwnProperty.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.hasOwnProperty.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.hasOwnProperty.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## Invalid #5 1 | const foo = {}.propertyIsEnumerable.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.propertyIsEnumerable.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.propertyIsEnumerable.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.propertyIsEnumerable\`.␊
    `

## Invalid #6 1 | [].forEach.call(foo, () => {})

> Output

    `␊
      1 | Array.prototype.forEach.call(foo, () => {})␊
    `

> Error 1/1

    `␊
    > 1 | [].forEach.call(foo, () => {})␊
        | ^^^^^^^^^^ Prefer using \`Array.prototype.forEach\`.␊
    `

## Invalid #7 1 | const push = [].push.bind(foo)

> Output

    `␊
      1 | const push = Array.prototype.push.bind(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const push = [].push.bind(foo)␊
        |              ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #8 1 | const foo = [][method].call(foo)

> Output

    `␊
      1 | const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [][method].call(foo)␊
        |             ^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## Invalid #9 1 | const method = "realMethodName";const foo = [][method].call(foo)

> Output

    `␊
      1 | const method = "realMethodName";const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = [][method].call(foo)␊
        |                                             ^^^^^^^^^^ Prefer using \`Array.prototype.realMethodName\`.␊
    `

## Invalid #10 1 | const array = Reflect.apply([].slice, foo, [])

> Output

    `␊
      1 | const array = Reflect.apply(Array.prototype.slice, foo, [])␊
    `

> Error 1/1

    `␊
    > 1 | const array = Reflect.apply([].slice, foo, [])␊
        |                             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #11 1 | Reflect.apply([].bar, baz, [])

> Output

    `␊
      1 | Reflect.apply(Array.prototype.bar, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply([].bar, baz, [])␊
        |               ^^^^^^ Prefer using \`Array.prototype.bar\`.␊
    `

## Invalid #12 1 | const foo = ({}).toString.call(bar);

> Output

    `␊
      1 | const foo = (Object.prototype).toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}).toString.call(bar);␊
        |             ^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #13 1 | const foo = ({}.toString).call(bar);

> Output

    `␊
      1 | const foo = (Object.prototype.toString).call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}.toString).call(bar);␊
        |              ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #14 1 | const foo = ({}.toString.call)(bar);

> Output

    `␊
      1 | const foo = (Object.prototype.toString.call)(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}.toString.call)(bar);␊
        |              ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #15 1 | function foo(){return[].slice.call(bar);}

> Output

    `␊
      1 | function foo(){return Array.prototype.slice.call(bar);}␊
    `

> Error 1/1

    `␊
    > 1 | function foo(){return[].slice.call(bar);}␊
        |                      ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #16 1 | function foo(){return{}.toString.call(bar)}

> Output

    `␊
      1 | function foo(){return Object.prototype.toString.call(bar)}␊
    `

> Error 1/1

    `␊
    > 1 | function foo(){return{}.toString.call(bar)}␊
        |                      ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #17 1 | Reflect.apply({}[Symbol()], baz, [])

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol()], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol()], baz, [])␊
        |               ^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## Invalid #18 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol("symbol description")], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## Invalid #19 1 | Reflect.apply([][Symbol()], baz, [])

> Output

    `␊
      1 | Reflect.apply(Array.prototype[Symbol()], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply([][Symbol()], baz, [])␊
        |               ^^^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## Invalid #20 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol("symbol description")], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## Invalid #21 1 | [][Symbol.iterator].call(foo)

> Output

    `␊
      1 | Array.prototype[Symbol.iterator].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | [][Symbol.iterator].call(foo)␊
        | ^^^^^^^^^^^^^^^^^^^ Prefer using \`Array.prototype.Symbol(Symbol.iterator)\`.␊
    `

## Invalid #22 1 | const foo = [].at.call(bar)

> Output

    `␊
      1 | const foo = Array.prototype.at.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].at.call(bar)␊
        |             ^^^^^ Prefer using \`Array.prototype.at\`.␊
    `

## Invalid #23 1 | const foo = [].findLast.call(bar)

> Output

    `␊
      1 | const foo = Array.prototype.findLast.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].findLast.call(bar)␊
        |             ^^^^^^^^^^^ Prefer using \`Array.prototype.findLast\`.␊
    `
