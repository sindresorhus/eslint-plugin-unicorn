# Snapshot report for `test/prefer-prototype-methods.mjs`

The actual snapshot is saved in `prefer-prototype-methods.mjs.snap`.

Generated by [AVA](https://avajs.dev).

## Invalid #1
      1 | const foo = [].push.apply(bar, elements);

> Output

    `␊
      1 | const foo = Array.prototype.push.apply(bar, elements);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].push.apply(bar, elements);␊
        |             ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #2
      1 | const foo = [].slice.call(bar);

> Output

    `␊
      1 | const foo = Array.prototype.slice.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].slice.call(bar);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #3
      1 | const foo = {}.toString.call(bar);

> Output

    `␊
      1 | const foo = Object.prototype.toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.toString.call(bar);␊
        |             ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #4
      1 | const foo = {}.hasOwnProperty.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.hasOwnProperty.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.hasOwnProperty.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## Invalid #5
      1 | const foo = {}.propertyIsEnumerable.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.propertyIsEnumerable.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.propertyIsEnumerable.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.propertyIsEnumerable\`.␊
    `

## Invalid #6
      1 | [].forEach.call(foo, () => {})

> Output

    `␊
      1 | Array.prototype.forEach.call(foo, () => {})␊
    `

> Error 1/1

    `␊
    > 1 | [].forEach.call(foo, () => {})␊
        | ^^^^^^^^^^ Prefer using \`Array.prototype.forEach\`.␊
    `

## Invalid #7
      1 | const push = [].push.bind(foo)

> Output

    `␊
      1 | const push = Array.prototype.push.bind(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const push = [].push.bind(foo)␊
        |              ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #8
      1 | const foo = bar.method.call(foo)

> Error 1/1

    `␊
    > 1 | const foo = bar.method.call(foo)␊
        |             ^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #9
      1 | const foo = bar[method].call(foo)

> Error 1/1

    `␊
    > 1 | const foo = bar[method].call(foo)␊
        |             ^^^^^^^^^^^ Prefer using method from the constructor prototype.␊
    `

## Invalid #10
      1 | const method = "realMethodName";const foo = bar[method].call(foo)

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = bar[method].call(foo)␊
        |                                             ^^^^^^^^^^^ Prefer using \`realMethodName\` method from the constructor prototype.␊
    `

## Invalid #11
      1 | const foo = [][method].call(foo)

> Output

    `␊
      1 | const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [][method].call(foo)␊
        |             ^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## Invalid #12
      1 | const method = "realMethodName";const foo = [][method].call(foo)

> Output

    `␊
      1 | const method = "realMethodName";const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = [][method].call(foo)␊
        |                                             ^^^^^^^^^^ Prefer using \`Array.prototype.realMethodName\`.␊
    `

## Invalid #13
      1 | const foo = [1].push.apply(bar, elements);

> Error 1/1

    `␊
    > 1 | const foo = [1].push.apply(bar, elements);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #14
      1 | const array = Reflect.apply([].slice, foo, [])

> Output

    `␊
      1 | const array = Reflect.apply(Array.prototype.slice, foo, [])␊
    `

> Error 1/1

    `␊
    > 1 | const array = Reflect.apply([].slice, foo, [])␊
        |                             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #15
      1 | Reflect.apply(foo.bar, baz, [])

> Error 1/1

    `␊
    > 1 | Reflect.apply(foo.bar, baz, [])␊
        |               ^^^^^^^ Prefer using \`bar\` method from the constructor prototype.␊
    `

## Invalid #16
      1 | Array["prototype"].slice.call();

> Error 1/1

    `␊
    > 1 | Array["prototype"].slice.call();␊
        | ^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`slice\` method from the constructor prototype.␊
    `

## Invalid #17
      1 | Array?.prototype.slice.call();

> Error 1/1

    `␊
    > 1 | Array?.prototype.slice.call();␊
        | ^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`slice\` method from the constructor prototype.␊
    `

## Invalid #18
      1 | window.Math.max.apply(null, numbers)

> Error 1/1

    `␊
    > 1 | window.Math.max.apply(null, numbers)␊
        | ^^^^^^^^^^^^^^^ Prefer using \`max\` method from the constructor prototype.␊
    `

## Invalid #1
      1 | const foo = {
      2 | 	a: () => {
      3 | 		this.method = this.method.bind(this);
      4 | 	}
      5 | }

> Error 1/1

    `␊
      1 | const foo = {␊
      2 | 	a: () => {␊
    > 3 | 		this.method = this.method.bind(this);␊
        | 		              ^^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
      4 | 	}␊
      5 | }␊
    `

## Invalid #2
      1 | const foo = {
      2 | 	[function() {this.method.bind(this);}]: 1
      3 | }

> Error 1/1

    `␊
      1 | const foo = {␊
    > 2 | 	[function() {this.method.bind(this);}]: 1␊
        | 	             ^^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
      3 | }␊
    `

## Invalid #3
      1 | const {foo} = {foo: {}};
      2 | const bar = foo.method.call(foo, 'property');

> Error 1/1

    `␊
      1 | const {foo} = {foo: {}};␊
    > 2 | const bar = foo.method.call(foo, 'property');␊
        |             ^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #4
      1 | const [foo] = [{}];
      2 | const bar = foo.method.call(foo, 'property');

> Error 1/1

    `␊
      1 | const [foo] = [{}];␊
    > 2 | const bar = foo.method.call(foo, 'property');␊
        |             ^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #5
      1 | const foo = {
      2 | 	a() {
      3 | 		this.propertyIsEnumerable.apply(this, []);
      4 | 	}
      5 | }

> Error 1/1

    `␊
      1 | const foo = {␊
      2 | 	a() {␊
    > 3 | 		this.propertyIsEnumerable.apply(this, []);␊
        | 		^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`propertyIsEnumerable\` method from the constructor prototype.␊
      4 | 	}␊
      5 | }␊
    `

## Invalid #6
      1 | const foo = {
      2 | 	a() {
      3 | 		function fn() {
      4 | 			// this is not the object foo
      5 | 			this.method.call(this);
      6 | 		}
      7 | 		return fn;
      8 | 	}
      9 | }

> Error 1/1

    `␊
      1 | const foo = {␊
      2 | 	a() {␊
      3 | 		function fn() {␊
      4 | 			// this is not the object foo␊
    > 5 | 			this.method.call(this);␊
        | 			^^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
      6 | 		}␊
      7 | 		return fn;␊
      8 | 	}␊
      9 | }␊
    `

## Invalid #7
      1 | this.method = this.method.bind(this)

> Error 1/1

    `␊
    > 1 | this.method = this.method.bind(this)␊
        |               ^^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #8
      1 | const foo = {};
      2 | const bar = foo.hasOwnProperty.call(foo, 'property');

> Error 1/1

    `␊
      1 | const foo = {};␊
    > 2 | const bar = foo.hasOwnProperty.call(foo, 'property');␊
        |             ^^^^^^^^^^^^^^^^^^ Prefer using \`hasOwnProperty\` method from the constructor prototype.␊
    `

## Invalid #9
      1 | for (const foo of []) foo.bar.call(foo)

> Error 1/1

    `␊
    > 1 | for (const foo of []) foo.bar.call(foo)␊
        |                       ^^^^^^^ Prefer using \`bar\` method from the constructor prototype.␊
    `

## Invalid #10
      1 | let foo = {};
      2 | const bar = foo.method.call(foo, 'property');

> Error 1/1

    `␊
      1 | let foo = {};␊
    > 2 | const bar = foo.method.call(foo, 'property');␊
        |             ^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #11
      1 | ({method() {}}).propertyIsEnumerable.call(foo)

> Error 1/1

    `␊
    > 1 | ({method() {}}).propertyIsEnumerable.call(foo)␊
        | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.propertyIsEnumerable\`.␊
    `
