# Snapshot report for `test/prefer-prototype-methods.mjs`

The actual snapshot is saved in `prefer-prototype-methods.mjs.snap`.

Generated by [AVA](https://avajs.dev).

## Invalid #1
      1 | const foo = [].push.apply(bar, elements);

> Output

    `␊
      1 | const foo = Array.prototype.push.apply(bar, elements);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].push.apply(bar, elements);␊
        |             ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #2
      1 | const foo = [].slice.call(bar);

> Output

    `␊
      1 | const foo = Array.prototype.slice.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].slice.call(bar);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #3
      1 | const foo = {}.toString.call(bar);

> Output

    `␊
      1 | const foo = Object.prototype.toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.toString.call(bar);␊
        |             ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## Invalid #4
      1 | const foo = {}.hasOwnProperty.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.hasOwnProperty.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.hasOwnProperty.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## Invalid #5
      1 | const foo = {}.propertyIsEnumerable.call(bar, "property");

> Output

    `␊
      1 | const foo = Object.prototype.propertyIsEnumerable.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.propertyIsEnumerable.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.propertyIsEnumerable\`.␊
    `

## Invalid #6
      1 | [].forEach.call(foo, () => {})

> Output

    `␊
      1 | Array.prototype.forEach.call(foo, () => {})␊
    `

> Error 1/1

    `␊
    > 1 | [].forEach.call(foo, () => {})␊
        | ^^^^^^^^^^ Prefer using \`Array.prototype.forEach\`.␊
    `

## Invalid #7
      1 | const push = [].push.bind(foo)

> Output

    `␊
      1 | const push = Array.prototype.push.bind(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const push = [].push.bind(foo)␊
        |              ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #8
      1 | const foo = bar.method.call(foo)

> Error 1/1

    `␊
    > 1 | const foo = bar.method.call(foo)␊
        |             ^^^^^^^^^^ Prefer using \`method\` method from the constructor prototype.␊
    `

## Invalid #9
      1 | const foo = bar[method].call(foo)

> Error 1/1

    `␊
    > 1 | const foo = bar[method].call(foo)␊
        |             ^^^^^^^^^^^ Prefer using method from the constructor prototype.␊
    `

## Invalid #10
      1 | const method = "realMethodName";const foo = bar[method].call(foo)

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = bar[method].call(foo)␊
        |                                             ^^^^^^^^^^^ Prefer using \`realMethodName\` method from the constructor prototype.␊
    `

## Invalid #11
      1 | const foo = [][method].call(foo)

> Output

    `␊
      1 | const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [][method].call(foo)␊
        |             ^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## Invalid #12
      1 | const method = "realMethodName";const foo = [][method].call(foo)

> Output

    `␊
      1 | const method = "realMethodName";const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = [][method].call(foo)␊
        |                                             ^^^^^^^^^^ Prefer using \`Array.prototype.realMethodName\`.␊
    `

## Invalid #13
      1 | const foo = [1].push.apply(bar, elements);

> Error 1/1

    `␊
    > 1 | const foo = [1].push.apply(bar, elements);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## Invalid #14
      1 | const array = Reflect.apply([].slice, foo, [])

> Output

    `␊
      1 | const array = Reflect.apply(Array.prototype.slice, foo, [])␊
    `

> Error 1/1

    `␊
    > 1 | const array = Reflect.apply([].slice, foo, [])␊
        |                             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## Invalid #15
      1 | Reflect.apply(foo.bar, baz, [])

> Error 1/1

    `␊
    > 1 | Reflect.apply(foo.bar, baz, [])␊
        |               ^^^^^^^ Prefer using \`bar\` method from the constructor prototype.␊
    `

## Invalid #16
      1 | Array["prototype"].slice.call();

> Error 1/1

    `␊
    > 1 | Array["prototype"].slice.call();␊
        | ^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`slice\` method from the constructor prototype.␊
    `

## Invalid #17
      1 | Array?.prototype.slice.call();

> Error 1/1

    `␊
    > 1 | Array?.prototype.slice.call();␊
        | ^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`slice\` method from the constructor prototype.␊
    `

## Invalid #18
      1 | window.Math.max.apply(null, numbers)

> Error 1/1

    `␊
    > 1 | window.Math.max.apply(null, numbers)␊
        | ^^^^^^^^^^^^^^^ Prefer using \`max\` method from the constructor prototype.␊
    `
