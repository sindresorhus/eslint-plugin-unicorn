# Snapshot report for `test/no-single-promise-in-promise-methods.mjs`

The actual snapshot is saved in `no-single-promise-in-promise-methods.mjs.snap`.

Generated by [AVA](https://avajs.dev).

## invalid(1): await Promise.all([promise])

> Input

    `␊
      1 | await Promise.all([promise])␊
    `

> Output

    `␊
      1 | await promise␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([promise])␊
        |                   ^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(2): await Promise.all([func()])

> Input

    `␊
      1 | await Promise.all([func()])␊
    `

> Output

    `␊
      1 | await func()␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([func()])␊
        |                   ^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(3): await Promise.all([promises[0]])

> Input

    `␊
      1 | await Promise.all([promises[0]])␊
    `

> Output

    `␊
      1 | await promises[0]␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([promises[0]])␊
        |                   ^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(4): await Promise.all([await promise])

> Input

    `␊
      1 | await Promise.all([await promise])␊
    `

> Output

    `␊
      1 | await promise␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([await promise])␊
        |                   ^^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(5): await Promise.any([promise])

> Input

    `␊
      1 | await Promise.any([promise])␊
    `

> Output

    `␊
      1 | await promise␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.any([promise])␊
        |                   ^^^^^^^^^ Wrapping a single element array with \`Promise.any()\` is unnecessary.␊
    `

## invalid(6): await Promise.race([promise])

> Input

    `␊
      1 | await Promise.race([promise])␊
    `

> Output

    `␊
      1 | await promise␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.race([promise])␊
        |                    ^^^^^^^^^ Wrapping a single element array with \`Promise.race()\` is unnecessary.␊
    `

## invalid(7): Promise.all([somethingMaybeNotPromise])

> Input

    `␊
      1 | Promise.all([somethingMaybeNotPromise])␊
    `

> Error 1/1

    `␊
    > 1 | Promise.all([somethingMaybeNotPromise])␊
        |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | somethingMaybeNotPromise␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | Promise.resolve(somethingMaybeNotPromise)␊
    `

## invalid(8): await Promise.all([new Promise(() => {})])

> Input

    `␊
      1 | await Promise.all([new Promise(() => {})])␊
    `

> Output

    `␊
      1 | await new Promise(() => {})␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([new Promise(() => {})])␊
        |                   ^^^^^^^^^^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(9): +await Promise.all([+1])

> Input

    `␊
      1 | +await Promise.all([+1])␊
    `

> Output

    `␊
      1 | +await (+1)␊
    `

> Error 1/1

    `␊
    > 1 | +await Promise.all([+1])␊
        |                    ^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(10): foo await Promise.all([(0, promise)])

> Input

    `␊
      1 | foo␊
      2 | await Promise.all([(0, promise)])␊
    `

> Output

    `␊
      1 | foo␊
      2 | await (0, promise)␊
    `

> Error 1/1

    `␊
      1 | foo␊
    > 2 | await Promise.all([(0, promise)])␊
        |                   ^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(11): foo Promise.all([(0, promise)])

> Input

    `␊
      1 | foo␊
      2 | Promise.all([(0, promise)])␊
    `

> Error 1/1

    `␊
      1 | foo␊
    > 2 | Promise.all([(0, promise)])␊
        |             ^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | foo␊
      2 | ;(0, promise)␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | foo␊
      2 | Promise.resolve((0, promise))␊
    `

## invalid(12): foo await Promise.all([[array][0]])

> Input

    `␊
      1 | foo␊
      2 | await Promise.all([[array][0]])␊
    `

> Output

    `␊
      1 | foo␊
      2 | await [array][0]␊
    `

> Error 1/1

    `␊
      1 | foo␊
    > 2 | await Promise.all([[array][0]])␊
        |                   ^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `

## invalid(13): foo Promise.all([[array][0]])

> Input

    `␊
      1 | foo␊
      2 | Promise.all([[array][0]])␊
    `

> Error 1/1

    `␊
      1 | foo␊
    > 2 | Promise.all([[array][0]])␊
        |             ^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | foo␊
      2 | ;[array][0]␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | foo␊
      2 | Promise.resolve([array][0])␊
    `

## invalid(14): Promise.all([promise]).then()

> Input

    `␊
      1 | Promise.all([promise]).then()␊
    `

> Error 1/1

    `␊
    > 1 | Promise.all([promise]).then()␊
        |             ^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | promise.then()␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | Promise.resolve(promise).then()␊
    `

## invalid(15): Promise.all([1]).then()

> Input

    `␊
      1 | Promise.all([1]).then()␊
    `

> Error 1/1

    `␊
    > 1 | Promise.all([1]).then()␊
        |             ^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | (1).then()␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | Promise.resolve(1).then()␊
    `

## invalid(16): Promise.all([(0, promise)]).then()

> Input

    `␊
      1 | Promise.all([(0, promise)]).then()␊
    `

> Error 1/1

    `␊
    > 1 | Promise.all([(0, promise)]).then()␊
        |             ^^^^^^^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 1/2: Use the value directly.␊
      1 | (0, promise).then()␊
    ␊
    --------------------------------------------------------------------------------␊
    Suggestion 2/2: Wrap the value with \`Promise.resolve()\`.␊
      1 | Promise.resolve((0, promise)).then()␊
    `

## invalid(17): await Promise.all([x ** y])

> Input

    `␊
      1 | await Promise.all([x ** y])␊
    `

> Output

    `␊
      1 | await (x ** y)␊
    `

> Error 1/1

    `␊
    > 1 | await Promise.all([x ** y])␊
        |                   ^^^^^^^^ Wrapping a single element array with \`Promise.all()\` is unnecessary.␊
    `
