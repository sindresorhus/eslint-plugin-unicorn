# Snapshot report for `test/prefer-prototype-methods.js`

The actual snapshot is saved in `prefer-prototype-methods.js.snap`.

Generated by [AVA](https://avajs.dev).

## invalid(1): const foo = [].push.apply(bar, elements);

> Input

    `␊
      1 | const foo = [].push.apply(bar, elements);␊
    `

> Output

    `␊
      1 | const foo = Array.prototype.push.apply(bar, elements);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].push.apply(bar, elements);␊
        |             ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## invalid(2): const foo = [].slice.call(bar);

> Input

    `␊
      1 | const foo = [].slice.call(bar);␊
    `

> Output

    `␊
      1 | const foo = Array.prototype.slice.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].slice.call(bar);␊
        |             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## invalid(3): const foo = {}.toString.call(bar);

> Input

    `␊
      1 | const foo = {}.toString.call(bar);␊
    `

> Output

    `␊
      1 | const foo = Object.prototype.toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.toString.call(bar);␊
        |             ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(4): const foo = {}.hasOwnProperty.call(bar, "property");

> Input

    `␊
      1 | const foo = {}.hasOwnProperty.call(bar, "property");␊
    `

> Output

    `␊
      1 | const foo = Object.prototype.hasOwnProperty.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.hasOwnProperty.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## invalid(5): const foo = {}.propertyIsEnumerable.call(bar, "property");

> Input

    `␊
      1 | const foo = {}.propertyIsEnumerable.call(bar, "property");␊
    `

> Output

    `␊
      1 | const foo = Object.prototype.propertyIsEnumerable.call(bar, "property");␊
    `

> Error 1/1

    `␊
    > 1 | const foo = {}.propertyIsEnumerable.call(bar, "property");␊
        |             ^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.propertyIsEnumerable\`.␊
    `

## invalid(6): [].forEach.call(foo, () => {})

> Input

    `␊
      1 | [].forEach.call(foo, () => {})␊
    `

> Output

    `␊
      1 | Array.prototype.forEach.call(foo, () => {})␊
    `

> Error 1/1

    `␊
    > 1 | [].forEach.call(foo, () => {})␊
        | ^^^^^^^^^^ Prefer using \`Array.prototype.forEach\`.␊
    `

## invalid(7): const push = [].push.bind(foo)

> Input

    `␊
      1 | const push = [].push.bind(foo)␊
    `

> Output

    `␊
      1 | const push = Array.prototype.push.bind(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const push = [].push.bind(foo)␊
        |              ^^^^^^^ Prefer using \`Array.prototype.push\`.␊
    `

## invalid(8): const foo = [][method].call(foo)

> Input

    `␊
      1 | const foo = [][method].call(foo)␊
    `

> Output

    `␊
      1 | const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [][method].call(foo)␊
        |             ^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## invalid(9): const method = "realMethodName";const foo = [][method].call(foo)

> Input

    `␊
      1 | const method = "realMethodName";const foo = [][method].call(foo)␊
    `

> Output

    `␊
      1 | const method = "realMethodName";const foo = Array.prototype[method].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | const method = "realMethodName";const foo = [][method].call(foo)␊
        |                                             ^^^^^^^^^^ Prefer using \`Array.prototype.realMethodName\`.␊
    `

## invalid(10): const array = Reflect.apply([].slice, foo, [])

> Input

    `␊
      1 | const array = Reflect.apply([].slice, foo, [])␊
    `

> Output

    `␊
      1 | const array = Reflect.apply(Array.prototype.slice, foo, [])␊
    `

> Error 1/1

    `␊
    > 1 | const array = Reflect.apply([].slice, foo, [])␊
        |                             ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## invalid(11): Reflect.apply([].bar, baz, [])

> Input

    `␊
      1 | Reflect.apply([].bar, baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Array.prototype.bar, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply([].bar, baz, [])␊
        |               ^^^^^^ Prefer using \`Array.prototype.bar\`.␊
    `

## invalid(12): const foo = ({}).toString.call(bar);

> Input

    `␊
      1 | const foo = ({}).toString.call(bar);␊
    `

> Output

    `␊
      1 | const foo = (Object.prototype).toString.call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}).toString.call(bar);␊
        |             ^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(13): const foo = ({}.toString).call(bar);

> Input

    `␊
      1 | const foo = ({}.toString).call(bar);␊
    `

> Output

    `␊
      1 | const foo = (Object.prototype.toString).call(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}.toString).call(bar);␊
        |              ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(14): const foo = ({}.toString.call)(bar);

> Input

    `␊
      1 | const foo = ({}.toString.call)(bar);␊
    `

> Output

    `␊
      1 | const foo = (Object.prototype.toString.call)(bar);␊
    `

> Error 1/1

    `␊
    > 1 | const foo = ({}.toString.call)(bar);␊
        |              ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(15): function foo(){return[].slice.call(bar);}

> Input

    `␊
      1 | function foo(){return[].slice.call(bar);}␊
    `

> Output

    `␊
      1 | function foo(){return Array.prototype.slice.call(bar);}␊
    `

> Error 1/1

    `␊
    > 1 | function foo(){return[].slice.call(bar);}␊
        |                      ^^^^^^^^ Prefer using \`Array.prototype.slice\`.␊
    `

## invalid(16): function foo(){return{}.toString.call(bar)}

> Input

    `␊
      1 | function foo(){return{}.toString.call(bar)}␊
    `

> Output

    `␊
      1 | function foo(){return Object.prototype.toString.call(bar)}␊
    `

> Error 1/1

    `␊
    > 1 | function foo(){return{}.toString.call(bar)}␊
        |                      ^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(17): Reflect.apply({}[Symbol()], baz, [])

> Input

    `␊
      1 | Reflect.apply({}[Symbol()], baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol()], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol()], baz, [])␊
        |               ^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## invalid(18): Reflect.apply({}[Symbol("symbol description")], baz, [])

> Input

    `␊
      1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol("symbol description")], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## invalid(19): Reflect.apply([][Symbol()], baz, [])

> Input

    `␊
      1 | Reflect.apply([][Symbol()], baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Array.prototype[Symbol()], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply([][Symbol()], baz, [])␊
        |               ^^^^^^^^^^^^ Prefer using method from \`Array.prototype\`.␊
    `

## invalid(20): Reflect.apply({}[Symbol("symbol description")], baz, [])

> Input

    `␊
      1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype[Symbol("symbol description")], baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply({}[Symbol("symbol description")], baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using method from \`Object.prototype\`.␊
    `

## invalid(21): [][Symbol.iterator].call(foo)

> Input

    `␊
      1 | [][Symbol.iterator].call(foo)␊
    `

> Output

    `␊
      1 | Array.prototype[Symbol.iterator].call(foo)␊
    `

> Error 1/1

    `␊
    > 1 | [][Symbol.iterator].call(foo)␊
        | ^^^^^^^^^^^^^^^^^^^ Prefer using \`Array.prototype.Symbol(Symbol.iterator)\`.␊
    `

## invalid(22): const foo = [].at.call(bar)

> Input

    `␊
      1 | const foo = [].at.call(bar)␊
    `

> Output

    `␊
      1 | const foo = Array.prototype.at.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].at.call(bar)␊
        |             ^^^^^ Prefer using \`Array.prototype.at\`.␊
    `

## invalid(23): const foo = [].findLast.call(bar)

> Input

    `␊
      1 | const foo = [].findLast.call(bar)␊
    `

> Output

    `␊
      1 | const foo = Array.prototype.findLast.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const foo = [].findLast.call(bar)␊
        |             ^^^^^^^^^^^ Prefer using \`Array.prototype.findLast\`.␊
    `

## invalid(24): /* globals hasOwnProperty: readonly */ hasOwnProperty.call(bar)

> Input

    `␊
      1 | /* globals hasOwnProperty: readonly */ hasOwnProperty.call(bar)␊
    `

> Output

    `␊
      1 | /* globals hasOwnProperty: readonly */ Object.prototype.hasOwnProperty.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | /* globals hasOwnProperty: readonly */ hasOwnProperty.call(bar)␊
        |                                        ^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## invalid(25): /* globals toString: readonly */ toString.apply(bar, [])

> Input

    `␊
      1 | /* globals toString: readonly */ toString.apply(bar, [])␊
    `

> Output

    `␊
      1 | /* globals toString: readonly */ Object.prototype.toString.apply(bar, [])␊
    `

> Error 1/1

    `␊
    > 1 | /* globals toString: readonly */ toString.apply(bar, [])␊
        |                                  ^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(26): /* globals toString: readonly */ Reflect.apply(toString, baz, [])

> Input

    `␊
      1 | /* globals toString: readonly */ Reflect.apply(toString, baz, [])␊
    `

> Output

    `␊
      1 | /* globals toString: readonly */ Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | /* globals toString: readonly */ Reflect.apply(toString, baz, [])␊
        |                                                ^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(27): globalThis.toString.call(bar)

> Input

    `␊
      1 | globalThis.toString.call(bar)␊
    `

> Output

    `␊
      1 | Object.prototype.toString.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | globalThis.toString.call(bar)␊
        | ^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(28): const _ = globalThis; _.hasOwnProperty.call(bar)

> Input

    `␊
      1 | const _ = globalThis; _.hasOwnProperty.call(bar)␊
    `

> Output

    `␊
      1 | const _ = globalThis; Object.prototype.hasOwnProperty.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const _ = globalThis; _.hasOwnProperty.call(bar)␊
        |                       ^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## invalid(29): const _ = globalThis; _["hasOwnProperty"].call(bar)

> Input

    `␊
      1 | const _ = globalThis; _["hasOwnProperty"].call(bar)␊
    `

> Output

    `␊
      1 | const _ = globalThis; Object.prototype.hasOwnProperty.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const _ = globalThis; _["hasOwnProperty"].call(bar)␊
        |                       ^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## invalid(30): const _ = globalThis; _["hasOwn" + "Property"].call(bar)

> Input

    `␊
      1 | const _ = globalThis; _["hasOwn" + "Property"].call(bar)␊
    `

> Output

    `␊
      1 | const _ = globalThis; Object.prototype.hasOwnProperty.call(bar)␊
    `

> Error 1/1

    `␊
    > 1 | const _ = globalThis; _["hasOwn" + "Property"].call(bar)␊
        |                       ^^^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.hasOwnProperty\`.␊
    `

## invalid(31): Reflect.apply(globalThis.toString, baz, [])

> Input

    `␊
      1 | Reflect.apply(globalThis.toString, baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply(globalThis.toString, baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(32): Reflect.apply(window.toString, baz, [])

> Input

    `␊
      1 | Reflect.apply(window.toString, baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply(window.toString, baz, [])␊
        |               ^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(33): Reflect.apply(global.toString, baz, [])

> Input

    `␊
      1 | Reflect.apply(global.toString, baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply(global.toString, baz, [])␊
        |               ^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(34): /* globals toString: readonly */ Reflect.apply(toString, baz, [])

> Input

    `␊
      1 | /* globals toString: readonly */ Reflect.apply(toString, baz, [])␊
    `

> Output

    `␊
      1 | /* globals toString: readonly */ Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | /* globals toString: readonly */ Reflect.apply(toString, baz, [])␊
        |                                                ^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `

## invalid(35): Reflect.apply(globalThis["toString"], baz, [])

> Input

    `␊
      1 | Reflect.apply(globalThis["toString"], baz, [])␊
    `

> Output

    `␊
      1 | Reflect.apply(Object.prototype.toString, baz, [])␊
    `

> Error 1/1

    `␊
    > 1 | Reflect.apply(globalThis["toString"], baz, [])␊
        |               ^^^^^^^^^^^^^^^^^^^^^^ Prefer using \`Object.prototype.toString\`.␊
    `
