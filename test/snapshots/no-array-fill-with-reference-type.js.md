# Snapshot report for `test/no-array-fill-with-reference-type.js`

The actual snapshot is saved in `no-array-fill-with-reference-type.js.snap`.

Generated by [AVA](https://avajs.dev).

## invalid(1): new Array(3).fill([]);

> Input

    `␊
      1 | new Array(3).fill([]);␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill([]);␊
        |                   ^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(2): new Array(3).fill(Array());

> Input

    `␊
      1 | new Array(3).fill(Array());␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(Array());␊
        |                   ^^^^^^^ Avoid using \`Array.fill()\` with reference type. Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(3): new Array(3).fill(new Array());

> Input

    `␊
      1 | new Array(3).fill(new Array());␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new Array());␊
        |                   ^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new Array()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(4): new Array(3).fill({}); // ✗ Object

> Input

    `␊
      1 | new Array(3).fill({});       // ✗ Object  ␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill({});       // ✗ Object  ␊
        |                   ^^ Avoid using \`Array.fill()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(5): new Array(3).fill(new Map()); // ✗ Map

> Input

    `␊
      1 | new Array(3).fill(new Map());       // ✗ Map␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new Map());       // ✗ Map␊
        |                   ^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new Map()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(6): new Array(3).fill(new Set()); // ✗ Set

> Input

    `␊
      1 | new Array(3).fill(new Set());       // ✗ Set␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new Set());       // ✗ Set␊
        |                   ^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new Set()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(7): new Array(3).fill(/pattern/); // ✗ RegExp

> Input

    `␊
      1 | new Array(3).fill(/pattern/); // ✗ RegExp␊
    `

> Options

    `␊
    [␊
      {␊
        "allowRegularExpressions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(/pattern/); // ✗ RegExp␊
        |                   ^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (RegExp). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(8): new Array(3).fill(new RegExp("pattern")); // ✗ RegExp

> Input

    `␊
      1 | new Array(3).fill(new RegExp("pattern")); // ✗ RegExp␊
    `

> Options

    `␊
    [␊
      {␊
        "allowRegularExpressions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new RegExp("pattern")); // ✗ RegExp␊
        |                   ^^^^^^^^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new RegExp()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(9): const p = /pattern/; new Array(3).fill(p); // ✗ RegExp

> Input

    `␊
      1 | const p = /pattern/; new Array(3).fill(p); // ✗ RegExp␊
    `

> Options

    `␊
    [␊
      {␊
        "allowRegularExpressions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | const p = /pattern/; new Array(3).fill(p); // ✗ RegExp␊
        |                                        ^ Avoid using \`Array.fill()\` with reference type (RegExp). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(10): const p = new RegExp("pattern"); new Array(3).fill(p); // ✗ RegExp

> Input

    `␊
      1 | const p = new RegExp("pattern"); new Array(3).fill(p); // ✗ RegExp␊
    `

> Options

    `␊
    [␊
      {␊
        "allowRegularExpressions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | const p = new RegExp("pattern"); new Array(3).fill(p); // ✗ RegExp␊
        |                                                    ^ Avoid using \`Array.fill()\` with reference type (new RegExp()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(11): new Array(3).fill(new String('fff')); // ✗ new String

> Input

    `␊
      1 | new Array(3).fill(new String('fff'));       // ✗ new String␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new String('fff'));       // ✗ new String␊
        |                   ^^^^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new String()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(12): new Array(3).fill(new Foo('fff')); // ✗ new Class

> Input

    `␊
      1 | new Array(3).fill(new Foo('fff'));       // ✗ new Class␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new Foo('fff'));       // ✗ new Class␊
        |                   ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new Foo()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(13): class BarClass {}; new Array(3).fill(BarClass); // ✗ Class

> Input

    `␊
      1 | class BarClass {}; new Array(3).fill(BarClass);       // ✗ Class␊
    `

> Error 1/1

    `␊
    > 1 | class BarClass {}; new Array(3).fill(BarClass);       // ✗ Class␊
        |                                      ^^^^^^^^ Avoid using \`Array.fill()\` with reference type. Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(14): class BarClass {}; new Array(3).fill(new BarClass()); // ✗ Class instance

> Input

    `␊
      1 | class BarClass {}; new Array(3).fill(new BarClass());       // ✗ Class instance␊
    `

> Error 1/1

    `␊
    > 1 | class BarClass {}; new Array(3).fill(new BarClass());       // ✗ Class instance␊
        |                                      ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new BarClass()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(15): const map = new Map(); new Array(3).fill(map); // ✗ Variable (map)

> Input

    `␊
      1 | const map = new Map(); new Array(3).fill(map);      // ✗ Variable (map)␊
    `

> Error 1/1

    `␊
    > 1 | const map = new Map(); new Array(3).fill(map);      // ✗ Variable (map)␊
        |                                          ^^^ Avoid using \`Array.fill()\` with reference type (new Map()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(16): Array(3).fill({}); // ✗ Object

> Input

    `␊
      1 | Array(3).fill({});       // ✗ Object  ␊
    `

> Error 1/1

    `␊
    > 1 | Array(3).fill({});       // ✗ Object  ␊
        |               ^^ Avoid using \`Array.fill()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(17): Array.from({ length: 3 }).fill({});

> Input

    `␊
      1 | Array.from({ length: 3 }).fill({});␊
    `

> Error 1/1

    `␊
    > 1 | Array.from({ length: 3 }).fill({});␊
        |                                ^^ Avoid using \`Array.from()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(18): new Array(3).fill(new Date())

> Input

    `␊
      1 | new Array(3).fill(new Date())␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new Date())␊
        |                   ^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new Date()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(19): Array.from({ length: 3 }).fill(new Date())

> Input

    `␊
      1 | Array.from({ length: 3 }).fill(new Date())␊
    `

> Error 1/1

    `␊
    > 1 | Array.from({ length: 3 }).fill(new Date())␊
        |                                ^^^^^^^^^^ Avoid using \`Array.from()\` with reference type (new Date()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(20): const initialArray = []; new Array(3).fill(initialArray); // ✗ Variable (array)

> Input

    `␊
      1 | const initialArray = []; new Array(3).fill(initialArray); // ✗ Variable (array)␊
    `

> Error 1/1

    `␊
    > 1 | const initialArray = []; new Array(3).fill(initialArray); // ✗ Variable (array)␊
        |                                            ^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(21): new Array(3).fill(() => 1);

> Input

    `␊
      1 | new Array(3).fill(() => 1);␊
    `

> Options

    `␊
    [␊
      {␊
        "allowFunctions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(() => 1);␊
        |                   ^^^^^^^ Avoid using \`Array.fill()\` with reference type (Function). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(22): new Array(3).fill(() => {});

> Input

    `␊
      1 | new Array(3).fill(() => {});␊
    `

> Options

    `␊
    [␊
      {␊
        "allowFunctions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(() => {});␊
        |                   ^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Function). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(23): new Array(3).fill(() => { return {} });

> Input

    `␊
      1 | new Array(3).fill(() => { return {} });␊
    `

> Options

    `␊
    [␊
      {␊
        "allowFunctions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(() => { return {} });␊
        |                   ^^^^^^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Function). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(24): new Array(3).fill(function () {});

> Input

    `␊
      1 | new Array(3).fill(function () {});␊
    `

> Options

    `␊
    [␊
      {␊
        "allowFunctions": false␊
      }␊
    ]␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(function () {});␊
        |                   ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Function). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(25): new Array(3).fill(new class {});

> Input

    `␊
      1 | new Array(3).fill(new class {});␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new class {});␊
        |                   ^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new class). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(26): new Array(3).fill(new A.B());

> Input

    `␊
      1 | new Array(3).fill(new A.B());␊
    `

> Error 1/1

    `␊
    > 1 | new Array(3).fill(new A.B());␊
        |                   ^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (new A.B). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(27): const cls = new class {}; new Array(3).fill(cls);

> Input

    `␊
      1 | const cls = new class {}; new Array(3).fill(cls);␊
    `

> Error 1/1

    `␊
    > 1 | const cls = new class {}; new Array(3).fill(cls);␊
        |                                             ^^^ Avoid using \`Array.fill()\` with reference type (new class). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(28): const obj = {}; Array.from({ length: 3 }).fill(obj);

> Input

    `␊
      1 | const obj = {}; Array.from({ length: 3 }).fill(obj);␊
    `

> Error 1/1

    `␊
    > 1 | const obj = {}; Array.from({ length: 3 }).fill(obj);␊
        |                                                ^^^ Avoid using \`Array.from()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(29): const map = new Map({ foo: "bar" }); Array.from({ length: 3 }, () => map);

> Input

    `␊
      1 | const map = new Map({ foo: "bar" }); Array.from({ length: 3 }, () => map);␊
    `

> Error 1/1

    `␊
    > 1 | const map = new Map({ foo: "bar" }); Array.from({ length: 3 }, () => map);␊
        |                                                                      ^^^ Avoid using \`Array.fill()\` with reference type (new Map()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(30): const map = new Map({ foo: "bar" }); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }

> Input

    `␊
      1 | const map = new Map({ foo: "bar" }); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
    `

> Error 1/1

    `␊
    > 1 | const map = new Map({ foo: "bar" }); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
        |                                                                                                       ^^^ Avoid using \`Array.fill()\` with reference type (new Map()). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(31): function getMap() { return new Map({ foo: "bar" }); } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }

> Input

    `␊
      1 | function getMap() { return new Map({ foo: "bar" }); } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
    `

> Error 1/1

    `␊
    > 1 | function getMap() { return new Map({ foo: "bar" }); } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
        |                                                                                                                                              ^^^ Avoid using \`Array.fill()\` with reference type. Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(32): function getMap() { return "literal string" } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }

> Input

    `␊
      1 | function getMap() { return "literal string" } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
    `

> Error 1/1

    `␊
    > 1 | function getMap() { return "literal string" } const map = getMap(); if (true) { const initialArray = Array.from({ length: 3 }, () => map); }␊
        |                                                                                                                                      ^^^ Avoid using \`Array.fill()\` with reference type. Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(33): const object = {} Array.from({length: 3}, () => object)

> Input

    `␊
      1 |␊
      2 | 		const object = {}␊
      3 | 		Array.from({length: 3}, () => object)␊
      4 | 		␊
    `

> Error 1/1

    `␊
      1 |␊
      2 | 		const object = {}␊
    > 3 | 		Array.from({length: 3}, () => object)␊
        | 		                              ^^^^^^ Avoid using \`Array.fill()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      4 | 		␊
    `

## invalid(34): const object = {}; Array.from({length: 31}).map(() => object);

> Input

    `␊
      1 | const object = {}; Array.from({length: 31}).map(() => object);␊
    `

> Error 1/1

    `␊
    > 1 | const object = {}; Array.from({length: 31}).map(() => object);␊
        |                                                       ^^^^^^ Avoid using \`Array.from()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(35): import { ref } from 'vue' let id = 0 const sharedObj = { id: `random-id-${++id}`, name: 'Tom', date: '2020-10-1', } const dataGenerator = () => (sharedObj) const data = ref(Array.from({ length: 200 }).map(dataGenerator))

> Input

    `␊
       1 |␊
       2 | 		import { ref } from 'vue'␊
       3 |␊
       4 | 		let id = 0␊
       5 |␊
       6 | 		const sharedObj = {␊
       7 | 			id: \`random-id-${++id}\`,␊
       8 | 			name: 'Tom',␊
       9 | 			date: '2020-10-1',␊
      10 | 		}␊
      11 |␊
      12 | 		const dataGenerator = () => (sharedObj)␊
      13 |␊
      14 | 		const data = ref(Array.from({ length: 200 }).map(dataGenerator))␊
      15 | 		␊
    `

> Error 1/1

    `␊
       1 |␊
       2 | 		import { ref } from 'vue'␊
       3 |␊
       4 | 		let id = 0␊
       5 |␊
       6 | 		const sharedObj = {␊
       7 | 			id: \`random-id-${++id}\`,␊
       8 | 			name: 'Tom',␊
       9 | 			date: '2020-10-1',␊
      10 | 		}␊
      11 |␊
    > 12 | 		const dataGenerator = () => (sharedObj)␊
         | 		                             ^^^^^^^^^ Avoid using \`Array.from()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      13 |␊
      14 | 		const data = ref(Array.from({ length: 200 }).map(dataGenerator))␊
      15 | 		␊
    `

## invalid(36): const arr = new Array(3); arr.fill([])

> Input

    `␊
      1 | const arr = new Array(3); arr.fill([])␊
    `

> Error 1/1

    `␊
    > 1 | const arr = new Array(3); arr.fill([])␊
        |                                    ^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(37): new Foo(3).fill({});

> Input

    `␊
      1 | new Foo(3).fill({});␊
    `

> Error 1/1

    `␊
    > 1 | new Foo(3).fill({});␊
        |                 ^^ Avoid using \`Array.fill()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(38): Foo(3).fill({});

> Input

    `␊
      1 | Foo(3).fill({});␊
    `

> Error 1/1

    `␊
    > 1 | Foo(3).fill({});␊
        |             ^^ Avoid using \`Array.fill()\` with reference type (Object). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(39): const obj = { arr: [] }; const arr = new Array(3).fill(obj.arr)

> Input

    `␊
      1 | const obj = { arr: [] }; const arr = new Array(3).fill(obj.arr)␊
    `

> Error 1/1

    `␊
    > 1 | const obj = { arr: [] }; const arr = new Array(3).fill(obj.arr)␊
        |                                                        ^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(40): const obj = { a: { b: { c: { list: [] } } } }; const arr = new Array(3).fill(obj.a.b.c.list);

> Input

    `␊
      1 |␊
      2 | 		const obj = { a: { b: { c: { list: [] } } } };␊
      3 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
      4 | 		␊
    `

> Error 1/1

    `␊
      1 |␊
      2 | 		const obj = { a: { b: { c: { list: [] } } } };␊
    > 3 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
        | 		                              ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      4 | 		␊
    `

## invalid(41): const obj2 = { a: { b: { c: { list: [] } } } }; const obj = { a: { b: { c: { list: [] } } } }; const arr = new Array(3).fill(obj.a.b.c.list);

> Input

    `␊
      1 |␊
      2 | 		const obj2 = { a: { b: { c: { list: [] } } } };␊
      3 | 		const obj = { a: { b: { c: { list: [] } } } };␊
      4 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
      5 | 		␊
    `

> Error 1/1

    `␊
      1 |␊
      2 | 		const obj2 = { a: { b: { c: { list: [] } } } };␊
      3 | 		const obj = { a: { b: { c: { list: [] } } } };␊
    > 4 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
        | 		                              ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      5 | 		␊
    `

## invalid(42): const obj2 = { a: { b: { c: { list: [] } } } }; const obj = { a: { b1: { c: { list: [] } } , b: { c1: { list: [] }, c: { list1: [], list: [] } } } }; const arr = new Array(3).fill(obj.a.b.c.list);

> Input

    `␊
      1 |␊
      2 | 		const obj2 = { a: { b: { c: { list: [] } } } };␊
      3 | 		const obj = { a: { b1: { c: { list: [] } } , b: {  c1: { list: [] }, c: {  list1: [], list: [] } } } };␊
      4 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
      5 | 		␊
    `

> Error 1/1

    `␊
      1 |␊
      2 | 		const obj2 = { a: { b: { c: { list: [] } } } };␊
      3 | 		const obj = { a: { b1: { c: { list: [] } } , b: {  c1: { list: [] }, c: {  list1: [], list: [] } } } };␊
    > 4 | 		const arr = new Array(3).fill(obj.a.b.c.list);␊
        | 		                              ^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      5 | 		␊
    `

## invalid(43): const obj = { list: [] }; const arr = new Array(3).fill(obj["list"])

> Input

    `␊
      1 | const obj = { list: [] }; const arr = new Array(3).fill(obj["list"])␊
    `

> Error 1/1

    `␊
    > 1 | const obj = { list: [] }; const arr = new Array(3).fill(obj["list"])␊
        |                                                         ^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
    `

## invalid(44): const obj = { a: { b: { c: { list: [] } } } }; const arr = new Array(3).fill(obj['a']['b']['c']['list']);

> Input

    `␊
      1 |␊
      2 | 		const obj = { a: { b: { c: { list: [] } } } };␊
      3 | 		const arr = new Array(3).fill(obj['a']['b']['c']['list']);␊
      4 | 		␊
    `

> Error 1/1

    `␊
      1 |␊
      2 | 		const obj = { a: { b: { c: { list: [] } } } };␊
    > 3 | 		const arr = new Array(3).fill(obj['a']['b']['c']['list']);␊
        | 		                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ Avoid using \`Array.fill()\` with reference type (Array). Use \`Array.from({ ... }, () => { return independent instance })\` instead to ensure no reference shared.␊
      4 | 		␊
    `
